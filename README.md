# java_16days_2weeks_document_practice
클래스 2주차 복습 및 교재 정리

1.  클래스 ( class )
> Java 에서 [클래스]란 [속성변수], [메소드], [생성자] 를 정의해 놓은 일종의 틀( = 템플릿 )이다.

     

     1) 메소드
     > 변수 / 연산자 / 조건문 / 반복문 사용, 객체 생성, 객체의 메소드 호출 등의 [ 실행 구문 ] 을 정의한다.

     > 실행 구문을 대표하는 이름으로 메소드 명을 지정하고 메소드 명을 호출하면 내부의 실행 구문이 실행된다.

     > 예) public double getAvg ( int kor, int eng ) { return (kor*eng)/3.0; }



     2) 속성변수
     > [기본형 데이터] 또는 [참조형 데이터] (= 객체의 메모리 위치 정보 데이터)를 저장한다.

     > 메소드 내부의 실행구문 실행과정 중에 필요한 데이터가 저장되는 곳이다.

     > 예) private int salary = 5000;



     3) 생성자
     > 클래스가 객체화 되면 자동으로 단 1회 실행할 [실행 구문] 을 정의한다.

     > 주로 객체 생성 후 사용할 속성변수에 데이터를 입력하는 코딩이 삽입된다.

     > 생성자 이름은 클래스 명과 동일하다.

     > 예) public Student( int kor, int eng) { this.kor = kor; this.eng = eng; }



     >> 하나의 클래스 내부에 개발자가 코딩하는 [속성변수], [메소드], [생성자]의 개수는 각각 0개 이상이다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

2. 클래스의 특징
> 클래스 파일( *.class )로 저장되어 있다.

     > 클래스 파일을 만들려면 자바 파일( ~. java) 을 만든 후 컴파일을 하면 클래스 파일이 생성된다.

> [클래스]에 정의된 [속성변수]와 [메소드] 를 호출하여 사용하려면 [Heap] 이란 메모리 공간에 올려놓고 호출한다.

   이때 [Heap] 이란 메모리 공간에 올라간 클래스를 [객체] (object) 또는 [인스턴스] (instance) 라고 부른다.

> 하나의 클래스는 여러 번 객체화하여 사용할 수 있다.

> 자주 사용되는 기능을 가진 [클래스] 들은 미리 만들어져 JDK 안에 내장되어 있다.

> (명심) 클래스를 객체화 하는 이유는 객체가 소유한 메소드 또는 속성변수를 호출하기 위함이다.



     <참고>

     1) 절차식 프로그래밍 
     > 변수/ 연산자/ 조건문/ 반복문 등을 사용하여 절차대로 프로그래밍 하는 것을 말한다.

     > 단점 => 코드의 재사용이 어렵다. 유지보수가 어렵다.



     2) 객체 지향 프로그래밍
     > [객체] 중심으로 프로그래밍 하는 것을 말한다.

        즉 [클래스] 를 객체화 한 후 메소드를 호출하면서 프로그래밍 하는 것을 말한다.

     > 장점

          > 메소드에 정의된 실행구문을 몰라도 메소드 호출만으로도 쉽게 전체 프로그램을 만들 수 있다.

          > 클래스로 정의되어 있으므로 코드의 재사용이 가능하여 유지 보수가 쉽다.



     > 절차식 프로그래밍과 객체 지향 프로그래밍의 비교 예

          > 국어, 영어, 수학 점수에서 평균 80 이상이면 합격, 미만이면 불합격 출력하는 코딩 만들기.



          > 절차식 프로그래밍의 예
          int kor = 90;

          int eng = 70;

          int mat = 80;



          int tot = kor + eng + mat;

          double avg = tot + mat;

          String result;

          if ( avg >= 80 ) {

               result = "합격";

          }else{

               result = "불합격";

          }

          System.out.print( result );



          > 객체 지향 프로그래밍의 예
          int kor = 90;

          int eng = 70;

          int mat = 80;



          Calculate cal = new Calculate( kor, eng, mat );

          System.out.print( cal.getResult( ) );

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

3. 클래스 구조
     1)  클래스 정의 형식
클래스명. java



package 패키지명;

import 수입클래스패키지명.수입클래스명;



[public] [abstract / final ] class 클래스명 {



     public/protected/default/private     [static]  [final]  기본자료형/클래스명/인터페이스명  속성변수명 [ = 데이터 ] ; 



     public/protected/default/private     생성자명  ( [자료형 매개변수, ~ ] )  {



                              실행구문;



     }



     public/protected/default/[private     [static] [synchronized] [abstract/final] 기본자료형/클래스명/인터페이스명/void  



     메소드명 ( [자료형 매개변수 , ~ ] ) {



                              실행구문;



     }





     > package 패키지명;

          > 클래스 소속 [묶음명]을 지정한다.

          > 패키지란 서로 기능이 비슷하거나 관련이 있는 [클래스] 또는 [인터페이스] 들을 묶어 놓은 묶음이다.

          > 관용적으로 패키지는 3단계 이상이다. <예> package com.naver.staff;



     > import 패키지명.수입클래스명;

          > 타 패키지 소속 클래스를 객체화하여 사용할 경우 수입할 패키지명과 클래스명을 지정한다. 0개 이상 선언할 수 있다.

          > 같은 패키지에 있는 타 클래스와 java.lang 패키지 안의 모든 클래스는 코딩 없이 자동으로 수입된다.

          > 수입클래스명 대신 *를 쓰면 해당 패키지의 모든 클래스를 수입한다.

              (예) import com.naver.staff.*; // com.naver.staff 패키지 안의 모든 클래스를 수입한다.



     > (주의) package ~ ; 구문 다음에 import ~ ;  구문이 나와야 한다. 순서가 바뀌면 컴파일이 불가능하다.

     > [속성변수], [생성자], [메소드] 를 클래스를 구성하는 [멤버] 라고 한다.

     > [속성변수], [생성자], [메소드] 는 각각 0개 이상 나올 수 있다.

     > [생성자명] 은 [클래스명] 과 동일하다.

     > [인터페이스] 는 [클래스와는 다를 형태의 단위 프로그램으로 추후 단원에서 배운다.

     > 메소드의 괄호 안의 [자료형 매개변수]는 0개 이상 나올 수 있다. 2개 이상 나올 경우 콤마(,)로 나열한다.

     > (참고) 하나의 java 파일 안에 2개 이상의 클래스를 선언하여 관리할 수 있다.

          이 경우 public static void main ( ) { ~ } 이 포함된 클래스만 클래스명 앞에 public이 붙을 수 있다.

          이 경우 보통 public static void main ( ) { ~ } 이 포함된 클래스의 클래스명을 파일명으로 한다.

                    ExeXxx.java

                    package 패키지명;

                    import 수입클래스패지지명.수입클래스명;

                    class Xxx {

                         ~

                    }

                    class ExeXxx{

                              public static void main( ) { ~ }

                    }



> 클래스 수입 지정자

          public                  > 같은 또는 다른 패키지의 타 클래스에서 수입이 가능하다.

          default ( 생략 )    > 같은 패키지의 타 클래스에서만 수입이 가능하다.

          > (명심) 클래스 수입 목적은 객체화한 후 메소드를 호출하기 위함이다.

> 클래스 성격 지정자 

         abstract          > 블록{ ~ } 이 없는 메소드를 하나 이상 소유한 클래스임을 지정한다. [추상클래스]라고 한다.

          final               > 자식 클래스를 가질 수 없는 클래스임을 지정한다.

                                > 상속이 불가능한 클래스임을 지정한다. [ 종단 클래스] 라고 한다.



> abstract 와 final 이 동시에 클래스명 앞에 올 수 없다.

          > abstract는 상속이 목적이고 final은 상속 불가가 목적이기 때문이다. ( 추후 상속과 추상클래스에서 자세히 설명)

> (참고) 상속

          > 어떤 [클래스] 가 소유한 멤버 ( 속성변수, 메소드 등) 를 다른 [클래스]에게 그대로 물려주는 것을 말한다.



     2)  속성변수
> [기본형 데이터] 또는 [ 참조형 데이터] ( = 객체 메모리 위치 주소값) 를 저장하는 변수다.

          > (참고)  메소드 안에 선언된 변수는 [속성변수] 가 아니라 [지역변수]로 메소드 안에서 선언되어 호출되고

                         메소드 종료 시 메모리 상에서 삭제된다.



> 속성변수 특징

          > 속성변수 선언 후 수동 초기화 하지 않으면 default 값으로 자동 초기화 된다.

          > (주의) [지역변수]는 수동 초기화 하지 않으면 자동 초기화 되지 않는다.

                       [지역변수]는 수동초기화 하지 않으면 선언 시에는 에러가 발생하지 않고 사용 시 에러가 난다.



                    할당(assignment)  > 변수에 데이터를 저장하는 행위

                    초기화(initialization)  > 변수 선언 후 처음 데이터를 저장하는 행위



> 속성변수 선언 형식

          public/protected/default/private    [static]    [final]    기본형/클래스명/인터페이스명    속성변수명 [= 데이터];



          > (참고) default 란 아무 접근지정자도 붙지 않음을 의미한다.

          > (참고) 메소드 안에 선언된 변수는 지역변수로 메소드 안에 선언되어 호출되고 메소드 종료시 삭제된다.

          > 메소드 안에 선언된 지역변수의 자료형 앞에 final이 붙으면 갱신이 불가능하다.



> 속성변수의 접근지정자

          > 타 클래스 메소드에서 [속성변수의 호출 가능 여부] 를 지정한다.

          > 관용적으로 대부분 [속성변수]는 private 를 붙여 타 클래스에서 직접 호출을 막는다.

          > 접근지정자 종류 및 기능은 21P를 참고한다.



> 속성변수의 성격지정자

          (1) final 

               > 처음에 저장된 데이터는 초기화 후 갱신을 금지한다.

               > (주의) final 이 붙은 속성변수는 예외적으로 자동 초기화되지 않으므로

                   반드시 변수 선언 동시에 수동 초기화 또는 생성자 안에서 수동 초기화해야한다.

               > final 이 붙은 변수를 [종단 변수] 라고 한다.



          (2) static

               > static 이 붙은 속성변수는 객체참조변수.속성변수명 또는 클래스명.속성변수명 형식으로

                  호출이 가능하고 이 속성변수를 소유한 모든 동일 객체가 공유하게 된다.

                       > 예) 객체 생성후      객참변수명.속성변수명 = 데이터1; 이 실행되면

                                클래스명.속성변수명 으로 호출해도      데이터 1이 저장되어 있다.

                       > 예) 클래스명.속성변수명 = 데이터1; 가 실행되면

                                객체 생성 후      객참변수명.속성변수명 으로 호출해도 데이터1 이 저장되어 있다.

               > 주의) static 이 없는 속성변수는 객체참조변수.속성변수명 형식으로만 호출이 가능하다.

               > 참고) static 이 붙는 변수를 [클래스 변수], [공유 변수] 라고도 한다.



> 속성변수의 자료 유형

          > 속성변수 안에 저장될 데이터의 유형을 설정한다.

          > 속성변수는 선언 후 수동 초기화하지 않으면 자동 초기화 된다.

                    주의) 예외적으로 final 이 붙은 속성변수는 자동 초기화 되지 않으므로 수동 초기화 해야 한다.

          > 참고) 지역 변수는 선언하자마자 자동 초기화 되지 않으므로 선언 후에 꼭 수동 초기화 해야한다.(안그럼오류)



> 속성 변수의 자료 유형 종류 및 의미

          1. 기본 자료형

                    > [기본형 데이터] 를 저장할 속성 변수에 붙인다.

                    > 기본형으로 속성변수를 선언하고 수동 초기화하지 않으면 다음과 같은 default 값으로 자동 초기화 된다.

                         => byte -> 0, short -> 0, int -> 0, long -> 0L, float -> 0.0F, double -> 0.0

                         => char -> " , boolean -> false



          2. 클래스명

                    > 아래와 같은 3가지 중 하나의 데이터를 저장할 속성 변수에 붙인다.

                              (1) 클래스명에 해당하는 클래스를 객체화한 [객체 메모리 위치 주소값]

                              (2) 클래스명에 해당하는 클래스의 후손 클래스를 객체화한 [객체 메모리 위치 주소값]

                              (3) null 값.

                    > 속성변수 앞에 클래스명을 붙이고 수동 초기화 하지 않으면 null 값으로 자동 초기화 된다.

                    > [객체의 메모리 위치 주소값]을 저장할 변수를 [참조형(reference type) 변수] 라고 한다.



          3. 인터페이스명

                    > 아래와 같은 2가지 중 하나의 데이터를 저장할 속성 변수에 붙인다.

                              (1) 인터페이스명에 해당하는 인터페이스를 구현한 클래스를 객체화한 [객체의 메모리 위치 주소값]

                              (2) null 값.

                    > 속성변수 앞에 인터페이스명을 붙이고 수동 초기화 하지 않으면 null 값으로 자동 초기화 된다.

                    > 인터페이스는 추후 단원에서 배운다.



     3). 메소드
> 실행 구문을 서술한 영역을 말한다. 이름을 붙여 선언하며 이름을 호출하면 실행 구문이 실행된다.



> 메소드 선언 형식

     public/protected/default/private     [static]     [synchronized]     [final/abstract] 

     기본자료형/ 클래스명/ 인터페이스명/ void     메소드명( [자료형 매개변수, ~] ) {



          실행구문;



     }



> 메소드의 접근지정자



          (1) static

                    > static 이 붙는 메소드는 객체참조변수.메소드명 또는 클래스명.메소드 형식으로 호출 가능하다.

                    > 주의 ) static 이 없는 메소드는 객체참조변수.메소드명 형식으로만 호출이 가능하다.

                    > 주의 ) static 이 붙은 메소드 안에서 나오는 동료 속성변수에는 static이 붙어야 한다.



          (2) final

                    > 소속 클래스를 타 클래스에 상속해줄 경우 타 클래스에서 메소드의 재정의를 불가능하게 한다.



          (3) abstract

                    > 바디 ( { ~ } ) 가 없는 메소드에 붙인다.

                    > 주의) 바디가 없는 메소드가 존재하면 클래스 앞에도 abstract 가 붙어야 한다.



          (4) synchronized

                    > 메소드 실행 중 일때 다른 스레드에서 호출 불가능 하게 한다.



> 메소드의 리턴형

     > [메소드]가 실행된 후에는 내놓는 [반환 데이터]의 자료 유형을 설정한다.



          (1) 기본 자료형

                    > [메소드] 실행 후 [기본 자료형]의 데이터를 반환한다.

                    > 주의) 메소드 내부에 반드시 return 기본자료형데이터;  가 있어야 한다.

                    > return의 의미는 메소드 실행을 중지하고 오른쪽 데이터를 호출한 곳으로 반환하라는 의미이다.

                    > 예) public int getCnt( ) { int cnt = 9; return cnt; }



          (2) 클래스명

                    > [메소드] 실행 후 아래와 같은 3가지 중 하나의 데이터를 리턴한다.

                              1) 클래스명에 해당하는 클래스를 객체화한 [객체의 메모리 위치 주소값]

                              2) 클래스명에 해당하는 클래스의 후손 클래스를 객체화한 [객체의 메모리 위치 주소값]

                              3) null 값. 

                    > 주의) 메소드 내부에   return  객체의 메모리 위치 주소값;이 있어야 한다.

                    > 예) public String getSname( ) { String sname = new String("사오정"); return sname; }



          (3) 인터페이스명

                    > [메소드] 실행 후 아래와 같은 2가지 중 하나의 데이터를 리턴한다.

                              1) 인터페이스명에 해당하는 인터페이스를 구현한 클래스를 객체화한 [객체 메모리 위치 주소값]

                              2) null 값.

                    > 주의) 메소드 내부에   retrun 객체의 메모리 위치 주소값;   이 있어야 한다.

                    > 인터페이스는 추후 단원에서 배운다.



          (4) void

                    > [메소드]가 실행 후에 아무런 값도 반환하지 않는다.

                    > 주의 ) 메소드 내부에 return 데이터; 가 있으면 안된다. 단 return; 은 있어도 된다.

                                 return; 은 메소드 종료 의미만 있기 때문이다.



> 매개변수

          > 데이터를 전달하면서 [메소드]를 호출할 때 전달 데이터를 저장할 변수이다.

          > [매개변수]는 0개 이상 나올 수 있다. 2개 이상일 경우 중간에 , 를 삽입한다.

          > 주의) [매개변수] 는 메소드 안에서만 사용되는 일종의 지역변수이다.



> 메소드 오버로딩(Overloading)

          > 같은 이름의 [메소드]를 2개 이상 정의하는 것을 말한다.

          > 주의) 메소드 오버로딩 규칙 => [메소드] 의 이름은 같고 [매개변수의 개수]나 [매개변수의 자료형]은 달라야 한다.

                                                            메소드의 리턴형은 오버로딩 규칙과 관계 없다.



> 메소드 안에 선언된 지역변수

          > [지역 변수] 는 메소드 호출 시 생성되고 메소드 종료 시 사라진다.

          > [지역 변수] 는 수동 초기화 하지 않는다고 [속성변수] 처럼 자동 초기화 되지 않는다.

          > [지역 변수] 는 수동 초기화 하지 않으면 선언 시에는 에러가 발생하지 않고 사용 시 에러가 발생한다.



     4) 생성자
> 클래스를 객체화 한 후 자동으로 한번만 호출되는 실행구문 영역을 말한다.



> 생성자 선언 형식



          public/protected/default/private     생성자명     ( [자료형 매개변수, ~] ) {



               실행구문;



          }

     

> 생성자 접근지정자

          > 생성자의 호출 가능여부를 지정한다.

          > 접근지정자 종류 및 기능은 21P 를 참고한다.



> 생성자 특징

          > 클래스를 객체화한 후 자동으로 단 한번만 호출된다.

          > 주의) 리턴형을 표시하지 않으므로 return 데이터; 가 있을 수 없다.

          > 생성자 호출 시 데이터를 전달해서 호출할 경우에는 매개변수를 설정한다.

                   예) 클래스명 객참변수 = new 클래스명 ( 데이터 ); 코딩 실행 시 데이터가 생성자 매개변수로 전달된다.

          > 생성자가 0개면 컴파일 시 기본 생성자인 public 생성자 ( ) { } 이 자동 삽입된다. 1개 이상이면 자동 삽입되지 않는다.



> 생성자 오버로딩 ( Overloading ) 

          > 같은 이름의 [생성자]를 2개 이상 정의하는 것을 말한다.

          > 생성자 오버로딩 규칙 => [생성자명]은 같더라도 [매개변수의 개수] 나 [매개변수의 자료형은 달라야한다.



> 생성자 호출 방법

          > new 에 의한 객체 생성 과정에서 new 생성자명( ~ ) 형식으로 호출

          > 동료 생성자 안에서 this( ~  ) 를 사용하여 호출

          > 자식 생성자 안에서 super( ~ ) 를 사용하여 호출

              주의) 동료 메서드 안에서 동료 생성자를 호출할 수는 없다.



4. 클래스로부터의 객체 생성 , 속성변수 / 메소드 호출 방법


> 절차 및 코딩 형식



     <1단계> 클래스 수입                 -> import 수입클래스패키지명.수입클래스명;



     <2단계> 클래스 객체화             -> 클래스명 객참변수 = new 생성자명 ( [ 데이터1, ~ ] ) ;



     <3단계> 속성변수/메소드 호출  -> 객참변수.속성변수명

                                                     -> 객참변수.메소드명 ( [데이터1,~] )



> 클래스명 객참변수 = new 생성자명 ( [ 데이터1, ~ ] );의 의미



     <1> [객참변수] 선언



     <2> [Method 영역] 에 존재하는 클래스 중 호출 가능한 생성자명 ( [데이터1, ~ ] ) 를 가진 클래스를 [Heap 영역]에 올린다.

              > [Heap 영역]에 올라간 클래스는 [객체]라고 부른다. (주의) 생성자명은 클래스명과 동일하다.

              > (주의) 생성자의 접근 지정자에 따라 호출 불가능 생성자면 에러가 발생한다.

              > (예) 생성자의 접근 지정자가 private 이면 누구도 객체 생성이 불가능하다. 



     <3> [객체]의 생성자명( [데이터1, ~] )를 호출한다.



     <4> [객체의 메모리 위치 주소값]을 리턴해서 [객참변수]에 저장



<정리> 결국 new의 기능은 [호출 가능 생성자를 소유한 클래스를 객체화 -> 생성자 호출 -> 객체의 메모리 위치 주소값 리턴] 이다





> (참고) 객체참조 변수 없이 객체 생성과 동시에 속성변수나 메소드를 호출 할 수도 있다. 이럴경우 객체참조 변수가 없으므로

            즉 객체의 메모리 위치 주소값을 모르므로 객체의 속성변수나 메소드의 재 호출이 불가능 하다.



                  > new 클래스명( [매개변수,~] ).속성변수명

                  > new 클래스명( [매개변수,~] ).메소드명( [데이터1,~] )



> (주의) 클래스 수입이 없으면 new에 의한 클래스 객체화가 불가능하므로 결국 속성변수, 메소드 호출도 불가능하다

> (주의) 클래스 수입을 하더라도 클래스의 객체화가 불가능하면 속성변수, 메소드 호출도 불가능하다 (예외) static 붙으면 가능.

> (주의) 클래스 수입을 하고 클래스 객체화가 가능하더라도 [접근 지정자]에 따라 속성변수,메소드 호출이 불가능할 수도 있다.



> (참고) static 이 붙은 속성변수 또는 메소드는 new 에 의한 객체 생성 코딩 없이



                 > 클래스명.속성변수명

                 > 클래스명.메소드명(~) 



            으로도 호출이 가능하며 객체 유무에 관계없이 호출한 모두가 공유한다.



> (참고) 부모클래스명 객참변수 = new 생성자명( [데이터1, ~ ] ) ; 형식으로도 가능하다. 추후 상속에서 배운다.

> (참고) 인터페이스명 객참변수 = new 생성자명( [데이터1, ~ ] ) ; 형식으로도 가능하다. 추후 인터페이스에서 배운다.





5. this 예약어
> [클래스]가 소유한 고유 멤버인 [속성변수], [메서드], [생성자] 를 지칭하거나

   [클래스] 가 객체화될 때 [객체의 메모리 위치 주소값] 을 말한다.



> 사용 형식

     > this.속성변수명         =    [클래스]의 고유 멤버인 속성변수 호출

     > this.메소드명( ~ )      =    [클래스]의 고유 멤버인 메소드 호출

     > this( ~ )                    =    [클래스]의 고유 멤버인 다른 동료 생성자 호출 

     > this                          =     this를 가진 [클래스]가 객체화 될 경우 객체의 메모리 위치 주소값 의미



> 사용 목적

     > 메소드의 [매개변수명]과 [속성변수명]이 같을 경우 구별하기 위해 "this.속성변수명" 형식으로 사용한다.

     > [부모클래스]와 [자식클래스]의 [속성변수] 또는 [메소드] 또는 [생성자] 의 이름이 같을 경우 구별하기 위해 사용한다.

        후에 상속을 배우는 과정에서 다룬다.



> (참고) 위 표에서 this 를 super 로 바꾸면 [부모 클래스] 쪽을 말한다. 추후 상속(inheritance)에서 다룬다.























